// Mock API for interacting with the off-chain verifier service.
// In a real application, this would make HTTPS requests to the Python server.
export interface RegisterPayload {
  potId: string;
  password: string;
  legend: Record<string, string>;
  oneFaAddress: string;
}
/**
 * Mocks the registration of a pot's challenge details with the verifier.
 * @param payload The registration data.
 * @returns A promise that resolves to a success status.
 */
export const registerPot = async (payload: RegisterPayload): Promise<{ success: boolean }> => {
  console.log("Mock API: Registering pot with verifier...", payload);
  // Simulate network delay
  await new Promise(resolve => setTimeout(resolve, 1000));
  // In a real scenario, you'd handle potential errors from the API.
  console.log("Mock API: Pot registered successfully.");
  return { success: true };
};
/**
 * Mocks fetching authentication options (challenges) from the verifier.
 * @param attemptId The attempt ID from the smart contract.
 * @returns A promise that resolves with mock challenges.
 */
export const getAuthOptions = async (attemptId: string): Promise<{ challenges: any[] }> => {
  console.log("Mock API: Getting auth options for attempt:", attemptId);
  await new Promise(resolve => setTimeout(resolve, 500));
  // This would be dynamically generated by the verifier based on pot difficulty.
  const mockChallenges = [
    { targetChar: 'Q', grid: generateMockGrid() },
    { targetChar: 'X', grid: generateMockGrid() },
    { targetChar: 'Z', grid: generateMockGrid() },
  ];
  console.log("Mock API: Returning mock challenges.");
  return { challenges: mockChallenges };
};
/**
 * Mocks verifying the user's solutions with the verifier.
 * @param challengeId The ID of the challenge being verified.
 * @param solutions An array of user-submitted solutions (directions).
 * @returns A promise that resolves to a success status.
 */
export const verifyAuth = async (challengeId: string, solutions: string[]): Promise<{ success: boolean }> => {
  console.log("Mock API: Verifying solutions for challenge:", challengeId, solutions);
  await new Promise(resolve => setTimeout(resolve, 1500));
  // The verifier would check the solutions against the stored password and legend.
  // We'll just mock a successful outcome.
  const success = Math.random() > 0.3; // 70% chance of success for demo
  console.log(`Mock API: Verification result: ${success}`);
  return { success };
};
// FIX: Updated to use the new 4-color palette
const generateMockGrid = () => Array.from({ length: 25 }).map((_, i) => ({
  id: i,
  color: ['bg-red-500', 'bg-green-500', 'bg-blue-500', 'bg-yellow-500'][Math.floor(Math.random() * 4)],
  char: String.fromCharCode(65 + Math.floor(Math.random() * 26)),
}));